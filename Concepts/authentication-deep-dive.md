---
topic: Authentication Deep Dive
category: web-security
tags: [security, web, authentication, jwt, session, deep-dive]
created: 2026-01-03
---

# 認証 深掘り：セッション vs トークン

Webアプリケーションの認証方式を攻撃者視点で理解する。

## 2つの認証方式

| 方式 | 状態の保持場所 | 特徴 |
|------|--------------|------|
| セッション方式 | サーバー側 | 従来型、ステートフル |
| トークン方式（JWT） | クライアント側 | モダン、ステートレス |

## セッション方式

### フロー

```
1. ログイン成功
   サーバー: セッションID生成 → メモリ/DBに保存
   クライアント: Cookieで受け取る

2. 以降のリクエスト
   クライアント: Cookie送信
   サーバー: セッションIDでユーザー情報を検索
```

### 課題（自分の分析）

> サーバーが複数台になったときの問題:
> - スケーラビリティに問題がある
> - サーバー間での同期処理に脆弱性が含まれそう
> - 同一IDのセッション処理が複数に現れてしまい、突破の糸口になる

| 問題 | 説明 |
|------|------|
| スケーラビリティ | サーバー追加ごとに同期が複雑化 |
| 単一障害点 | 共有ストア（Redis等）がダウン → 全員ログアウト |
| 同期の脆弱性 | 同期処理のバグが突破口に |
| ステートフル | サーバーが状態を持つ = 運用が複雑 |

## トークン方式（JWT）

### フロー

```
1. ログイン成功
   サーバー: トークン生成 → 署名付きでクライアントに渡す
   サーバー: 何も保存しない

2. 以降のリクエスト
   クライアント: トークンを送信
   サーバー: 署名を検証 → 改ざんされていなければ信頼
```

**サーバーは状態を持たない（ステートレス）。**

### JWTの構造

```
ヘッダー.ペイロード.署名
```

| 部分 | 内容 | 役割 |
|------|------|------|
| ヘッダー | `{"alg": "HS256", "typ": "JWT"}` | 検証方法の指定 |
| ペイロード | `{"user_id": 42, "role": "admin"}` | 実際のデータ |
| 署名 | HMAC-SHA256(ヘッダー.ペイロード, 秘密鍵) | 改ざん検知 |

### なぜ暗号化されていないのか（自分の疑問）

> 「ペイロードこそ公開鍵と秘密鍵の仕組みが活かせそう」と思った。

**回答:**
- JWTの目的は「改ざん防止」であって「秘匿」ではない
- ペイロードはクライアント自身の情報（知っていて問題ない）
- 重要なのは「書き換えられないこと」と「検証できること」

### 署名アルゴリズム

| 方式 | 鍵 | 用途 |
|------|-----|------|
| HS256 | 共通鍵（対称） | 単一サービス |
| RS256 | 公開鍵/秘密鍵（非対称） | マイクロサービス |

**RS256の利点:**
```
認証サーバー: 秘密鍵でトークンに署名
APIサーバーA: 公開鍵で検証
APIサーバーB: 公開鍵で検証
```
秘密鍵を共有せずに、複数サーバーで検証できる。

## JWT の脆弱性

### 1. alg: none 攻撃

```json
{
  "alg": "none",  ← 署名なしで信頼してください
  "typ": "JWT"
}
```

**攻撃フロー:**
1. 有効なJWTを取得
2. ペイロードを改ざん（role: "admin"）
3. ヘッダーを alg: "none" に変更
4. 署名を空にして送信

**根本原因（自分の分析）:**
> 「どう検証するか」をクライアントが指定できてしまう。
> これは「ユーザー入力を信頼しない」という原則に反している。

**対策:** サーバーが使用するアルゴリズムを固定する。

### 2. その他の脆弱性

| 脆弱性 | 内容 |
|--------|------|
| alg混同 | RS256→HS256に変え、公開鍵を共通鍵として使用 |
| 期限切れ無視 | exp検証の実装漏れ |
| 秘密鍵の漏洩 | 任意のトークンを偽造可能 |
| トークン失効不可 | ログアウトしても有効なまま |

## トークン失効問題

### 問題

JWTはステートレス。ログアウト時にトークンをどう無効化するか？

### 解決策

**方法1：ブロックリスト**
```
ログアウト時 → トークンIDをリストに追加
検証時 → ブロックリストを確認
```
問題：サーバーが状態を持つ

**方法2：短い有効期限 + リフレッシュトークン**
```
アクセストークン: 15分で期限切れ
リフレッシュトークン: 7日間（サーバーで管理）

ログアウト時:
→ リフレッシュトークンを失効
→ アクセストークンは最大15分で自然消滅
```

**方法3：トークンバージョン（自分の発想に近い）**
```
DB: user_id=42, token_version=5
JWT: {"user_id": 42, "token_version": 5}

ログアウト時 → token_version を 6 に更新
検証時 → バージョンが一致しなければ拒否
```

### トレードオフ

| 方式 | ステートレス度 | 即時失効 |
|------|--------------|----------|
| ブロックリスト | 低 | 可能 |
| 短い有効期限 | 高 | 不可（最大N分の遅延） |
| トークンバージョン | 中 | 可能（全セッション） |

**完全なステートレスと即時失効は両立しない。**

## セッション vs JWT 比較

| 項目 | セッション方式 | JWT方式 |
|------|--------------|---------|
| 状態 | サーバー側 | クライアント側 |
| スケール | 同期が必要 | 容易 |
| 失効 | 容易 | 工夫が必要 |
| 脆弱性 | セッション固定、窃取 | alg:none、失効不可 |

## まとめ

認証方式の選択はトレードオフ:
- **セッション**: 制御しやすいがスケールしにくい
- **JWT**: スケールしやすいが失効が難しい

どちらを選んでも、その方式固有の脆弱性を理解して対策することが重要。

## 関連

- [[sqli-deep-dive]] - SQLインジェクション深掘り
- [[xss-deep-dive]] - XSS深掘り
- [[owasp-top-10]] - 全体像
