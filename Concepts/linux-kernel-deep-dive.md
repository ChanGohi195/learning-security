---
topic: Linux Kernel Security Deep Dive
category: linux-security
tags: [security, linux, kernel, namespace, cgroups, container, cloud, deep-dive]
created: 2026-01-03
---

# Linux カーネルセキュリティ深掘り

全てのクラウドサービスの基盤となるLinuxカーネルを理解する。

## なぜLinuxが最高の教材か

```
コンテナ → Linux kernel (namespace, cgroups)
Docker → Linux の機能をラップ
AWS/GCP/Azure → Linux 上で動作
世界のサーバーの96%以上 → Linux
```

**上に行くほど便利、下に行くほど本質。**

## カーネルとは

```
┌─────────────────────────────────────┐
│ ユーザー空間（User Space）           │
│   アプリ、シェル、Docker、...        │
└──────────────┬──────────────────────┘
               │ システムコール
               ↓
┌─────────────────────────────────────┐
│ カーネル空間（Kernel Space）         │
│   プロセス管理、メモリ管理、          │
│   ファイルシステム、ネットワーク      │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│ ハードウェア                         │
└─────────────────────────────────────┘
```

**カーネル = ハードウェアとソフトウェアの仲介者**

## システムコール（syscall）

アプリは直接ハードウェアを触れない。必ずカーネルを経由。

### なぜ直接アクセスさせないか

| 理由 | 説明 |
|------|------|
| リソース管理 | 無制限に使われると他が動かない |
| セキュリティ | 悪意あるアプリがディスクを破壊できてしまう |
| 安定性 | バグのあるアプリがシステム全体をクラッシュ |
| 抽象化 | ハードウェアの違いを吸収 |

**カーネル = 資源の番人**

## Linuxセキュリティの5層

```
┌─────────────────────────────────────┐
│ SELinux / AppArmor                  │
│   「何にアクセスできるか」（MAC）     │
├─────────────────────────────────────┤
│ seccomp                             │
│   「どのシステムコールを呼べるか」    │
├─────────────────────────────────────┤
│ Capabilities                        │
│   「どの特権操作ができるか」         │
├─────────────────────────────────────┤
│ cgroups                             │
│   「どれだけリソースを使えるか」     │
├─────────────────────────────────────┤
│ Namespace                           │
│   「何が見えるか」                   │
└─────────────────────────────────────┘
```

## Namespace 詳細

| Namespace | 分離するもの |
|-----------|-------------|
| pid | プロセスID（他のプロセスが見えない） |
| net | ネットワーク（独自のIPアドレス） |
| mnt | ファイルシステム（独自のルート） |
| user | ユーザーID（コンテナ内でroot） |
| uts | ホスト名 |
| ipc | プロセス間通信 |

### PID Namespace

```
ホストから見た世界:
  PID 1: init
  PID 5678: コンテナ内のアプリ

コンテナ内から見た世界:
  PID 1: コンテナ内のアプリ ← 自分が最初のプロセスに見える
  ホストの他のプロセス → 見えない
```

**存在を知らなければ攻撃できない。**

### Mount Namespace

```
-v オプションの意味:
  docker run -v /host/path:/container/path

  明示的に「穴を開ける」操作
  だから -v /:/host が危険
```

## cgroups（Control Groups）

Namespaceは「何が見えるか」。cgroupsは「どれだけ使えるか」。

### リソース制限がないと

```
攻撃者 → コンテナAに侵入
    ↓
無限ループ / フォーク爆弾
    ↓
CPU 100% / メモリ枯渇
    ↓
全コンテナ + ホスト機能停止
```

**1コンテナの侵害 → 全体のDoS**

### cgroupsで制限

| リソース | 攻撃の防止 |
|----------|-----------|
| CPU | マイニング、DoS |
| メモリ | メモリ枯渇 |
| プロセス数 | フォーク爆弾 |
| I/O | ディスク占有 |

## Capabilities

```
従来:
  root → 全ての権限

capabilities:
  root権限を約40種類に細分化
  → 必要な権限だけ付与可能
```

### 危険なCapabilities

| Capability | できること |
|------------|-----------|
| CAP_SYS_ADMIN | ほぼ全て（事実上root） |
| CAP_NET_ADMIN | ネットワーク設定変更 |
| CAP_SYS_PTRACE | 他プロセスのデバッグ |

## seccomp

### Capabilities vs seccomp

| 項目 | Capabilities | seccomp |
|------|-------------|---------|
| 方式 | 権限を与える | 操作を禁止する |
| 粒度 | 約40種類 | 300以上のsyscall |

### 自分の理解

> ポジティブリストとネガティブリストの違いに相当。
> 絶対に起きてはいけない操作を指定できる分seccompの方が頑健。

### 多層防御

```
攻撃者の目標: mount() を実行したい

第1層 Capabilities:
  CAP_SYS_ADMIN がない → mount() 失敗

  しかし権限昇格に成功したら？

第2層 seccomp:
  mount() syscall 自体がブロック → 権限があっても実行不可
```

## SELinux / AppArmor（MAC）

```
DAC（従来）:
  rootはすべてにアクセス可能
  rootを取られたら終わり

MAC:
  「このプロセスは、このファイルにしかアクセスできない」
  rootでも変更不可（カーネルレベルで強制）
```

## その他のカーネルセキュリティ

### /proc と /sys

```bash
cat /proc/1234/environ  # 環境変数（機密情報含む可能性）
cat /proc/1234/cmdline  # コマンドライン引数
```

**PID namespaceで分離しないと全プロセスの情報が丸見え。**

### ASLR

```
ASLRなし: libcは常に同じアドレス → 攻撃者は事前に知っている
ASLRあり: アドレスが毎回ランダム → 推測が必要
```

### カーネルモジュール

```
カーネルモジュール = カーネル空間で動くコード = 全権限

Rootkit:
  システムコールテーブルを改ざん
  → ls しても攻撃者のファイルが見えない
  → ps しても攻撃者のプロセスが見えない
  → 全ての監視ツールが嘘をつく状態
```

## 防御機能の悪用

### 自分の気づき

> セキュリティ機能 = 中立な「力」
> 防御者が使えば盾、攻撃者が使えば武器
> 権限を取得していれば実質誘拐しているのと変わらない

| 機能 | 防御的使用 | 攻撃的使用 |
|------|-----------|-----------|
| iptables | 不正アクセスをブロック | 管理者をロックアウト |
| cgroups | リソース制限 | 正規プロセスを停止 |
| カーネルモジュール | セキュリティ強化 | rootkit注入 |

## クラウドでの規模感

### 自分の気づき

> これがクラウドサービスだったら凄まじい威力。
> Linux偉大すぎる。結局カーネルのデザインがそのまま各種クラウドサービスの機能の根底にある。

```
オンプレミス:
  1カーネル = 1サーバー = 1組織の被害

クラウド:
  1ハイパーバイザー = 数百のVM = 数百の顧客
  1カーネル脆弱性 = 同一ホスト上の全テナント
```

### Meltdown / Spectre (2018)

```
CPUの投機的実行を悪用:
  VM → ハイパーバイザーのメモリ
  コンテナ → ホストのメモリ

影響:
  全てのIntel CPU（過去20年分）
  ソフトウェアでは完全に修正不可能
```

**ハードウェアレベルの脆弱性 = 全クラウドに影響**

## クラウドベンダーの分離強化

| 技術 | 説明 |
|------|------|
| Dedicated Hosts | 物理サーバーを専有 |
| Nitro System | ハイパーバイザーを極小化 |
| Firecracker | microVM、カーネル非共有 |
| gVisor | ユーザー空間カーネル |
| Confidential Computing | ハードウェア暗号化、ベンダーも見られない |

### 分離技術の進化

| 世代 | 技術 |
|------|------|
| 第1世代 | VM（ハイパーバイザー分離） |
| 第2世代 | コンテナ（カーネル機能分離） |
| 第3世代 | microVM（Firecracker） |
| 第4世代 | gVisor（ユーザー空間カーネル） |
| 第5世代 | Confidential Computing |

## なぜ脆弱性は起きるか

### 設定ミス

```bash
--privileged
--cap-add=ALL
-v /:/host
--security-opt seccomp=unconfined
```

**5層の防御を自ら無効化。**

### ライブラリ/カーネル脆弱性

```
CVE-2019-5736 (runc):
  seccompもcapabilitiesも関係なく脱獄成功
```

**技術的に可能な防御があっても、運用で崩壊する。**

## 設計思想の継承

```
Unix哲学（1970年代）:
  「一つのことをうまくやる」
  「小さなツールを組み合わせる」
      ↓
Linux（1991年〜）:
  namespace, cgroups, capabilities...
  各機能は単純、組み合わせて強力に
      ↓
コンテナ/クラウド（2010年代〜）:
  マイクロサービス
```

**50年前の設計思想が今も生きている。**

## まとめ

```
Linuxカーネル
    │
    ├── namespace, cgroups, capabilities, seccomp, SELinux
    │
    ↓
Docker, Kubernetes, Firecracker, gVisor
    │
    ↓
AWS Lambda, Cloud Run, 全てのクラウドサービス
```

**1991年にLinus Torvaldsが始めたプロジェクトが、世界のインフラを支えている。**

## 関連

- [[container-deep-dive]] - コンテナセキュリティ
- [[docker-deep-dive]] - Docker
- [[authentication-deep-dive]] - 認証
- [[sqli-deep-dive]] - SQLインジェクション
