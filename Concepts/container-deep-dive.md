---
topic: Container Security Deep Dive
category: cloud-security
tags: [security, container, docker, supply-chain, deep-dive]
created: 2026-01-03
---

# コンテナセキュリティ深掘り

コンテナのライフサイクル全体を通じたセキュリティを理解する。

## コンテナとは何か

### 本質的な理解

> 「アプリと、その実行に必要な全てをパッケージ化したもの」
>
> Git = コードのバージョン管理
> Docker = 「動く状態」のバージョン管理

### VMとの違い

| 観点 | VM | コンテナ |
|------|-----|---------|
| 分離方法 | ハイパーバイザー | カーネル機能（namespace, cgroups） |
| カーネル | 各VMが独自に持つ | ホストと共有 |
| サイズ | GB単位 | MB単位 |
| 起動 | 分単位 | 秒単位 |
| セキュリティ境界 | 強い | 相対的に弱い |

**コンテナはプロセスの隔離。VMのような「別マシン」ではない。**

### 自分の気づき

> Vercelが「意味不明なのに便利」だった理由 = 見事なカプセル化。
> Docker/コンテナの概念を全て隠蔽し、git pushだけでデプロイ可能にしている。
> 抽象化の恩恵を受けていたが、裏の仕組みを知ることで「選択」できるようになる。

## コンテナのライフサイクル

```
1. ビルド（Build） → Dockerfile → イメージ作成
2. 配布（Ship）    → レジストリにpush/pull
3. 実行（Run）     → コンテナとして起動
```

## 各段階のセキュリティリスク

### 自分の分析

> 被害のスケーラビリティでは配布〜実行段階。
> 機密漏洩ではビルド段階が危険。

## 1. ビルド段階

### 機密漏洩

```dockerfile
# 悪い例：シークレットがイメージに焼き込まれる
ENV DATABASE_URL=postgres://user:password@db.example.com/prod
```

イメージの履歴やinspectで機密情報が見える。

### 対策：マルチステージビルド

```dockerfile
FROM node:18 AS builder
COPY . .
RUN --mount=type=secret,id=npm_token npm install

FROM node:18-alpine
COPY --from=builder /app/dist /app
# シークレットは最終イメージに残らない
```

## 2. 配布段階

### サプライチェーン攻撃

- Typosquatting（python:3.9 → pythonn:3.9）
- 正規イメージに見せかけたマルウェア
- レジストリ自体の侵害

**被害のスケール：数千〜数百万のシステムに影響。**

### 対策：署名と検証

```bash
# Docker Content Trust
export DOCKER_CONTENT_TRUST=1
docker pull nginx:latest  # 署名検証

# Cosign（現代的アプローチ）
cosign sign myregistry/myapp:v1.0
cosign verify myregistry/myapp:v1.0
```

### 署名の保証範囲

> 署名は「作成者の真偽性」を保証する。
> しかし「プログラムの脆弱性や悪意の有無」は保証しない。

| 保証する | 保証しない |
|----------|-----------|
| 作成者が本物か | 脆弱性がないか |
| 改ざんされていないか | 悪意がないか |

## 3. 脆弱性スキャン

```bash
trivy image nginx:1.19

# 結果例
Total: 125 (HIGH: 23, CRITICAL: 5)
```

### スキャンの限界

> 依存関係が複雑になり、数も多くなれば指数関数的に未知の脆弱性が含まれうる。
> 新規ライブラリも増えるとなると把握が困難。
> 故にリスクフリーには本質的になりようがない。

| 検出できる | 検出できない |
|-----------|-------------|
| 既知の脆弱性（CVE） | ゼロデイ |
| 公開ライブラリ | 独自コードの欠陥 |

## 4. 実行段階

### 危険な設定

```bash
docker run --privileged -v /:/host ubuntu
# → 事実上のホストアクセス
```

| オプション | 危険性 |
|-----------|--------|
| --privileged | 全capabilities付与 |
| -v /:/host | ホストFS全体をマウント |
| --net=host | ネットワーク分離なし |
| --pid=host | プロセス分離なし |

### ベストプラクティス

```dockerfile
# 非rootユーザーで実行
USER appuser

# 読み取り専用ファイルシステム
docker run --read-only myapp
```

## 侵入前提の設計（Assume Breach）

### 自分の理解

> 優れたアーキテクチャの思想性はセキュリティにも応用できる。
> アーキテクチャをそもそも分離しておけば被害も局所化できる。
> 侵入された時にそこからスケールしなければ良い、という考え。

### 従来 vs 現代

| 従来（境界防御） | 現代（ゼロトラスト） |
|-----------------|---------------------|
| 城壁で守る | 城壁は突破される前提 |
| 内部は信頼 | 内部も信頼しない |
| 侵入させない | 侵入されても被害限定 |

### Blast Radius（爆発半径）の最小化

| 対策 | 効果 |
|------|------|
| ネットワーク分離 | 横展開防止 |
| 最小権限 | 権限昇格防止 |
| 読み取り専用FS | 永続化防止 |
| リソース制限 | DoS/マイニング防止 |

## 多層防御

```
┌─────────────────────────┐
│ ネットワーク分離         │ ← 1層目
├─────────────────────────┤
│ イメージスキャン         │ ← 2層目
├─────────────────────────┤
│ 署名検証                 │ ← 3層目
├─────────────────────────┤
│ 最小権限                 │ ← 4層目
├─────────────────────────┤
│ ランタイム監視           │ ← 5層目
└─────────────────────────┘
```

**1つ突破されても次の層で止める。**

## CI/CDパイプラインでの実装

```
git push
    ↓
ビルド（docker build）
    ↓
スキャン（trivy scan）
    ↓ 脆弱性あり → 失敗
    ↓ 脆弱性なし
署名（cosign sign）
    ↓
レジストリにpush
    ↓
本番デプロイ時に署名検証
```

## まとめ

| 段階 | リスク | 対策 | 限界 |
|------|--------|------|------|
| ビルド | 機密漏洩 | マルチステージ | 独自コードの欠陥 |
| 配布 | サプライチェーン | 署名、スキャン | ゼロデイ |
| 実行 | 脱獄、権限昇格 | 最小権限、監視 | 検知遅延 |

**全Phaseを通じた原則: 分離によって被害を局所化する**

## 関連

- [[sqli-deep-dive]] - SQLインジェクション
- [[xss-deep-dive]] - XSS
- [[authentication-deep-dive]] - 認証
- [[kubernetes-security]] - 次のトピック
